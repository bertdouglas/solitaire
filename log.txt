------------------------------------------------------------------------
2023-06-10 Wednesday

Decided to make a new struct CardVec and hang some methods on it to
convert to and from other types like Vec<u8>.
For making tests, it is awkward and overly cluttered to initialize a vector of Cards.

Problem is there is no good way in rust to change the type of a vector
even if the underlying types both have size of one byte.

If you use idiomatic iterators with NoOp map function, then supposedly
the copy is optimized away.  Having trouble properly constructing
the iterator from Vec<u8> back to Vec<Card>.  Maybe I am doing it wrong.
Or maybe it is impossible without writing a custom Fromiterator function.

There is also a feature in "nightly" that converts a vector into "raw parts"
which can then be used to make a new vector.

    #![feature(vec_into_raw_parts)]

    fn convert_using_into_raw_parts(v: Vec<T>) -> Vec<U> {
        let (ptr, len, cap) = v.into_raw_parts();
        unsafe { Vec::from_raw_parts(ptr as *mut U, len, cap) }
    }

There is also a crate that does something similar.  Uses a regular
struct instead of a tuple struct.  Impossible to get fields in wrong order.
And don't have to use nightly rust.

      use raw_parts::RawParts;

      let v: Vec<i32> = vec![-1, 0, 1];

      let RawParts { ptr, length, capacity } = RawParts::from_vec(v);

      let rebuilt = unsafe {
          // We can now make changes to the components, such as
          // transmuting the raw pointer to a compatible type.
          let ptr = ptr as *mut u32;
          let raw_parts = RawParts { ptr, length, capacity };

          RawParts::into_vec(raw_parts)
      };
      assert_eq!(rebuilt, [4294967295, 0, 1]);

-----------------------------
Back at night.  Got the iterator version working.  Wrote a timing test
to see how it is optimized.

    bertd@ghd-asb:~/0repos/solitaire$ cargo run -r --example test_card_vec
       Compiling solitaire v0.1.0 (/home/bertd/0repos/solitaire)
        Finished release [optimized] target(s) in 0.38s
         Running `target/release/examples/test_card_vec`
    vector sizes :  [100, 10000, 1000000]
    to_u8 times  :  [5.9000000000000006e-8, 3.7e-8, 5.5e-8]
    from_u8 times:  [4.3400000000000005e-7, 2.889e-6, 0.00044496700000000005]

to_u8 takes same time even on large vector.
from_u8 takes 100 times longer on long vector.
It is even 10 times longer on short vector.

Looks like I need to go to the raw parts method.

------------------------------------------------------------------------
2023-04-30 Sunday

Found that there are unicode characters in standard linux
console fond that represent card suits. Sadly they are almost
too small to see.  The codes are u2660 to u2667.

    println!("\u{2660} \u{2661} \u{2662} \u{2663} ");
    println!("\u{2664} \u{2665} \u{2666} \u{2667} ");

    ♠ ♡ ♢ ♣
    ♤ ♥ ♦ ♧

It looks like the solid black ones would be most useful.
Still I wonder if using a single letter abbreviation might be easier
to read.  SHDC  ♠♥♦♣

It is possible to increase font size on console.  But this makes it
fill the screen, and also makes regular letters bigger as well.

I wonder about color.

    use colored::Colorize;
    println!("{}","\u{2660} \u{2661} \u{2662} \u{2663} ".red().on_white() );
    println!("{}","\u{2664} \u{2665} \u{2666} \u{2667} ".red().on_white() );
    println!("{}","\u{2660} \u{2661} \u{2662} \u{2663} ".black().on_white() );
    println!("{}","\u{2664} \u{2665} \u{2666} \u{2667} ".black().on_white() );

This works. Although the white is not really white.  More like a light grey.

I want to make a simple display that is functional, but not
skeuomorphic like the usual solitaire games. No overlapping cards. I
just want to get working display as easy as possible, and generic as
possible.

Decide to still with plain text, no special characters.
Experiment more with color.

Well the 8 traditional colors are not right.
Use so called truecolor rgb instead.  At least with the "colored" crate.

Not sure how much abbreviation is appropriate.
What is the maximum number of solitaire cards in a pile or group?
in the Tableau, 13 cards k through a
Same in the foundation

Initial deal has 7 piles in the tableau with 1 through 7 cards
so the sum is 7*8/2 = 28
So the stock pile has initially 52 - 28 = 24 cards
So that is the biggest pile initially
If all are displayed, using 3 characters each, it takes 96 columns.
Doable.

How many piles total, stock, waste, f1 to f4 t1 to t7
2+4+7 = 13
The waste does not need to be displayed, so only 12
There are usually 24 lines, should be enough
Many piles, as in tableau will have to be adjacent

I am thinking about horizontal piles, turned 90 degrees normal.
Right to left, instead of top down.  This could be done without
any heavy duty console engine.

Try 2460 block of unicode in console.\
Works.

installed a rust solitaire game from
https://github.com/florimondmanca/solitaire-rs

No docs.  figured out some.  Seems incomplete. Used a
cursor that points to a pile.  Space bar selects.  Then move cursor, then
hit space again.  Enter key moves ace to foundation.
Can't figure out how to get next card from stock.
Some definite bugs.  Cursor disappears when it is on the selected pile.
But it is a good demo of how to do vertical layout on console.
Now obvious that anything without drag and drop is going to be a pain.
The suit symbols were readable.




------------------------------------------------------------------------
2023-04-25 Wednesday

Look more at speed.  Is it reasonable.
Assume 1 microsecond per shuffle.
52 cards
1 instruction per nanosecond
that is 1000/52 = 19 instructions per card
Does not seem reasonable.

Take a look at assembly code.

------------------------------------------------------------------------
2023-04-25 Tuesday

Worked last night.  Did not make any logs.

Today got shuffle test going.
Added timestamps to determine shuffle rate.
It is coming back as 1.5 million/second.
It is hard to see how you can even get 52 random numbers in less
than a microsecond.

So far everything seems to be working correctly as soon as compiler
bugs are removed.  Hard to believe.

Need to check that work is actually being done.
Perhaps try some of the benchmark features of rust.

------------------------------------------------------------------------
2023-04-23 Sunday

Yesterday worked all day and half the night.
But not much got logged.

Rewrote nearly all of the deck module.
Using closures for array of struct initialization.
Trying to meet two opposing goals.
  - pretty code that has all info together one place easy to read
  - efficient to access with u8 and [u8;n]
The initializer syntax in rust is weak.  Ask around and they say
"use a macro".  Well I am not ready for that yet.
Also rust, unlike c, will not convert between integer types automatically.
If you use a neat quoted string, which is easy to read, then you have
a type &str, which takes a lot of clutter to convert to [u8;n]
If you code the source as ["a","b","c"] then the code is harder to read
and you get long lines, or folded lines

Right now I have neat source initializers and compact targert but
a whole lot of code to convert one to the other.

Had a nice experience with the iterator and any()
It seems like things just work with iterators.
That part of the compiler is more polished.

Try to convert some more code to iterators.

Got one success right away.  With compiler hint, learned about
try_into(), which solves one problem I was having last night.

Learned that there are two kinds of asserts.
regular assert is always compiled in both for debug and release
debug_assert is elided in release mode and only present in debug mode

discovered that my way of converting &str to &[u8] requires
them to both be the same size.
  "abc".as_bytes().try_into().unwrap()

So what to do?
  keep in the struct
  convert to string stored elsewhere, with ref
  pad with spaces and access with trim()
  probably would be going against convention to put zero terminator
  try to make a slice that refers to buffer in same struct

Not working

      error[E0204]: the trait `Copy` may not be implemented for this type
        --> src/deck.rs:60:17
         |
      60 | #[derive(Clone, Copy, Debug, Default)]
         |                 ^^^^
      ...
      65 |     repr1  : [u8],  // these slices point to buffer in struct
         |     ------------- this field does not implement `Copy`

Obviously I don't understand what is happening with slices.
Is a slice simply a sequence of bytes?
Or is it a pointer and length referring to a sequence of bytes

I am tangled up in something too complicated.  The Lazy init requires
constructing a copy of the needed data structure, which is then returned
from the closure and copied into the static array of structs.

Too many macros.  Hard to understand or debug.  Probably some corner
cases in them not handled correctly.  Too much magic.  Get rid of Once
Cell.  With a little bit of code can do my own init, instead of trying
to hide it and make it fancy.

Here we go again.  Not sure I am converging.  But the key to performance
is compact tables.  This is good for cache.  With all the strings and slices
and references the data must be spread out.

Well, hit a brick wall here as well.  Static have all sorts of restrictions
and mutable statics are worse.

    error[E0015]: cannot call non-const fn `<RankInfo as Default>::default` in statics
      --> src/deck.rs:67:35
       |
    67 | static RANK_INFO_BLANK:RankInfo = Default::default();

    error[E0015]: cannot call non-const fn `<RankInfo as Default>::default` in statics
      --> src/deck.rs:67:35
       |
    67 | static RANK_INFO_BLANK:RankInfo = Default::default();

I think that I am beginning to get the message.  Forget about statics.

One more time.  Make a function that constructs the rankinfo
and returns a reference.  Hope the compiler optimizes it.

Ok.  That worked ok. Can't return a reference.  That leaves ownership
inside the function.  But returning the whole thing works. Obviously I
don't fully understand it. Not many problems.  Good stuff with the fstr
type strings.  Had to get rid of derive Default on the RankInfo.  But
it was not needed in new scheme, as constructing each value and then
pushing to a vector.

Built for release and looked for the function.  It was not there.
Looked in main.  All inlined.  Less than one screen of code, all of
it doing the test function.

how can compiler be this smart?

So I got it cache friendly, all in code section in immutable table,
and easy to read.  Success.

There is problem with the rank_next() concept.  The rule for testing
for next is broken at the unused card, the knight.  Maybe should
just get rid of the unused cards.  Too tired to do it now.
Still have to rewrite the rest of the init.

------------------------------------------------------------------------
2023-04-22 Saturday

Thinking ahead to what will be needed.
Ability to display a card.
Standard abbreviations for debug display

Testing if a card is red or black.
Seeing how good the inlining is, I think it best to provide a method
for this, even if it is a trivial method.  Hide the masks from the api.

ability to manipulate game states, and move cards from one pile to
another.

Dealing with game states seems sufficiently large and different
so that it should be a separate module from the "deck" module.

perhaps deck is not the best name.  Maybe "card" would be better.

Do we really need the ordinal deck?  It was as a bridge to faster
shuffle, by shuffling the ordinals, then looking up the bitcode.
Extra lookup seems to take enough time to overcome any speed of
working with ordinals.

For today, continue and do more unit tests and get rid of some of
the unused code warnings.

------------------------------------------------------------------------
2023-04-21 Friday

Changed a lot of init to lazy static.
They ran into a problem that could not be fixed.
Latest version of compiler now recommends
"once_cell::Lazy"
So I converted all the lazy inits.
Also moved most of code to new module called "deck".
Changed the main deck to a regular struck.  Got rid of the type state
attempt.
Still need to convert some functions to be methods of struct Deck.
Change args to shuffle.  Put the call to get random bits inside of
shuffle.  Why did I do this?  Oh.  It was to allow comparison of two
different shuffle functions, one obvious simple code, and the other
intricate index manipulation.

It compiles and runs
but does little so far.  I like the closure, which avoids having to make
a special one use named function as with lazy static.
------------------------------------------------------------------------
2023-04-20 Thursday

Found that cargo-asm is abandoned.
Instead there is new project called cargo-show-asm which
does roughly same thing but better and active.
Give it a try.
cargo uninstall cargo-asm
cargo install cargo-show-asm
cargo asm shuffle_main

It worked.  Nice colors.  No source code to speak of.
Much less junk than raw .s file.
more references have meaningful names, all library functions, like alloc, panic
Function is completely inlined.

rustup component add rust-src
cargo asm --rust  solitaire::main > main.asm

now getting more source code.
The entirety of make_ordinals reduced to a sequence of moves inlined in main.
But the source code refers only to one line in the middle of make ordinals.
Most helpfully the reference includes the line number.
Ovbiously there is a table somewhere.  Why not reference it directly
instead of doing moves.
Not impressed with type states.  Seems to get in the way.
See if I can convert make ordinals so it is handled completely at compile time.
Perhaps take another look at lazy static.

		// /home/bertd/0repos/solitaire/src/main.rs : 216
		out.0[i] = i as u8;
	movaps xmm0, xmmword ptr [rip + .LCPI24_0]
	movaps xmmword ptr [rsp + 224], xmm0

	movaps xmm0, xmmword ptr [rip + .LCPI24_1]
	movaps xmmword ptr [rsp + 240], xmm0

	movaps xmm0, xmmword ptr [rip + .LCPI24_2]
	movaps xmmword ptr [rsp + 256], xmm0

	mov dword ptr [rsp + 272], 858927408

This is moving 52 bytes.  Using xmm registers it loads and stores
16 bytes, three times, moving 48 bytes.  Then it moves 4 additional
bytes from an immediate source, making 52 in all.

.LCPI24_0:
	.byte	0
	.byte	1
	.byte	2
	.byte	3
	.byte	4
	.byte	5
	.byte	6
	.byte	7
	.byte	8
	.byte	9
	.byte	10
	.byte	11
	.byte	12
	.byte	13
	.byte	14
	.byte	15

This is amazing optimization.  With a little more hint, it should be
able to get rid of the move.

Decide to rewrite out a deck object, with variant forms.
Start coding.  Improve a bunch of names.
Use lots of lazy static, whenever possible.

Have to stop.  Half complete.

------------------------------------------------------------------------
2023-04-18 Tuesday
Learning to look at assembly language
follow advice on web.

      RUSTFLAGS="--emit asm" cargo bench --bench foo

      cargo asm --asm-style=intel \
         --rust equart::quadtree::Boundry::subarea

      cargo asm --rust crate::klondike_suits

Could not find any relevant output in release mode.
But this gave some results.  Strange looking assembly.

      RUSTFLAGS="--emit asm" cargo clean
      RUSTFLAGS="--emit asm" cargo build

In the debug directory found this searching for klondike.

                .section	.text._ZN9solitaire14klondike_suits17h318c732eb4fa0095E,"ax",@progbits
                .p2align	4, 0x90
                .type	_ZN9solitaire14klondike_suits17h318c732eb4fa0095E,@function
              _ZN9solitaire14klondike_suits17h318c732eb4fa0095E:
              .Lfunc_begin247:
                .loc	1 155 0
                .cfi_startproc
                .loc	1 161 2 prologue_end
                leaq	_ZN9solitaire14klondike_suits2KS17he916c8a044ee2a49E(%rip), %rax
                retq
              .Ltmp2569:
              .Lfunc_end247:
                .size	_ZN9solitaire14klondike_suits17h318c732eb4fa0095E, .Lfunc_end247-_ZN9solitaire14klondike_suits17h318c732eb4fa0095E
                .cfi_endproc

So it appears, indeed, that the function was optimized away into a
table built at compile time.  I wonder how complicated the code can get and
still run at compile time.  At run time it is merely a single load
effective address instruction and return.

In the release version, this function goes away completely and it is inlined.
Got to be a better way to find the code and read it.

------------------------------------------------------------------------
2023-04-17 Monday

I timed the shuffle test.  User time is:   2m38.310s
1e7 calls to shuffle and to get random bits
ghci> ((2*60)+38.31)/1e7
1.5831e-5

That is surprisingly fast.
About 16 microseconds per iteration.  And each iteration
handles 52 items.  How can it be that fast?
At 2GHZ that is 32k cycles.  That is the top down.
Bottom up guess, (52*2*10) 1040 instructions
That leaves in middle 32 clocks per instruction.
Seem high.  Perhaps more like 4 to 10.

Wonder if the bulk is in random number generation or in the shuffle.
Investigate if possible to get a vector of numbers in a single call
to random number generator.


------------------------------------------------------------------------
2023-04-16 Sunday

Coded a test function for shuffle.  Made a deck in sequence, ordinals.
Shuffled 10 times.  Inserted into a hash table.  Repeat a million
times. Ran several times.  No duplicates found. Look at some of
shuffles.  Looks normal.  So this looks like a good shuffle function.

Found that if you want to see console output of successful tests, then
you must add this flag.  I think that the console output of failing
tests is displayed. I guess normally you don't care about output from
passing tests, and there are probably a lot of tests, and it would get
cluttered.

    cargo test -- --nocapture
